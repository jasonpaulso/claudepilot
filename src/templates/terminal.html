<!--
/**
 * Terminal Webview HTML Template
 * 
 * Purpose:
 * - Provides the HTML structure for the Claude Pilot terminal webview
 * - Uses template placeholders that get replaced by TemplateUtils
 * - Ensures proper VS Code theme integration through CSS variables
 * 
 * Responsibilities:
 * - Define the terminal container element
 * - Load required xterm.js libraries and addons
 * - Apply VS Code theme-compatible styling
 * - Execute the terminal initialization script
 * 
 * Template Variables:
 * - {{TIMESTAMP}} - Cache-busting timestamp
 * - {{XTERM_URI}}, {{XTERM_CSS_URI}} - xterm.js core resources
 * - {{FIT_ADDON_URI}}, {{WEBGL_ADDON_URI}}, {{CANVAS_ADDON_URI}} - xterm.js addons
 * - {{TERMINAL_SCRIPT}} - Complete terminal initialization JavaScript
 * 
 * Notes:
 * - Background transparency is crucial for VS Code theme inheritance
 * - All styling uses CSS custom properties from VS Code
 * - Script injection happens at template processing time, not runtime
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Claude Code Terminal</title>
    <!-- Timestamp {{TIMESTAMP}} to force webview refresh -->
    <link rel="stylesheet" href="{{XTERM_CSS_URI}}" />
    <style>
        body {
            margin: 0;
            padding: 16px;
            height: 100vh;
            box-sizing: border-box;
            overflow: hidden;
            background-color: var(--vscode-terminal-background, #1e1e1e);
            color: var(--vscode-terminal-foreground, #cccccc);
            font-family: var(--vscode-editor-font-family, 'Courier New', monospace);
        }
        
        #terminal {
            width: 100%;
            height: calc(100% - 16px);
            transition: all 0.2s ease;
        }
        
        #terminal.drag-over::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(128, 128, 128, 0.3);
            pointer-events: none;
            z-index: 1000;
        }
        
        #terminal {
            position: relative;
        }
        
        #drag-hint {
            position: absolute;
            top: 4px;
            right: 8px;
            font-size: 11px;
            color: var(--vscode-descriptionForeground, #888);
            font-family: var(--vscode-font-family, system-ui);
            pointer-events: none;
            z-index: 9999;
            opacity: 0;
            transform: scale(0.8) translateY(-8px);
            transition: all 0.2s cubic-bezier(0.2, 0, 0.2, 1);
            background: var(--vscode-editor-background, rgba(0,0,0,0.9));
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--vscode-widget-border, #454545);
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            white-space: nowrap;
        }
        
        #drag-hint.show {
            opacity: 0.95;
            transform: scale(1) translateY(0);
        }
        
        /* Ensure xterm uses transparent background to inherit VS Code theme */
        .xterm {
            background-color: transparent !important;
        }
        
        .xterm .xterm-viewport {
            background-color: transparent !important;
        }
        
        .xterm .xterm-screen {
            background-color: transparent !important;
        }
    </style>
</head>
<body>
    <script type="text/javascript">
    let isDragActive = false;
    let isDragInProgress = false; // Track if a drag is happening somewhere
    let hintTimeout = null;
    let hasShownHintForCurrentDrag = false; // Prevent multiple hints per drag session
    
    function setupDragCapture() {
        // Use capture phase to intercept events before VS Code
        document.addEventListener('dragenter', handleDragEnter, true);
        document.addEventListener('dragover', handleDragOver, true);
        document.addEventListener('dragleave', handleDragLeave, true);
        document.addEventListener('drop', handleDrop, true);
        document.addEventListener('dragend', handleDragEnd, true);
        
        // Reset on mouse interactions
        document.addEventListener('mouseup', resetAllDragState);
        document.addEventListener('click', resetAllDragState);
    }
    
    
    function resetAllDragState() {
        isDragActive = false;
        isDragInProgress = false;
        hasShownHintForCurrentDrag = false; // Reset hint tracking
        const terminal = document.getElementById('terminal');
        terminal.classList.remove('drag-over');
        hideDragHint(); // Hide hint when drag operation completely ends
    }
    
    function handleDragEnd(ev) {
        resetAllDragState();
    }
    
    function handleDragEnter(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        Object.defineProperty(ev, 'shiftKey', { value: true, writable: false });
        dragenter(ev);
    }
    
    function handleDragOver(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        Object.defineProperty(ev, 'shiftKey', { value: true, writable: false });
        dragover(ev);
    }
    
    function handleDragLeave(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        Object.defineProperty(ev, 'shiftKey', { value: true, writable: false });
        dragleave(ev);
    }
    
    function handleDrop(ev) {
        ev.preventDefault();
        ev.stopPropagation();
        ev.stopImmediatePropagation();
        Object.defineProperty(ev, 'shiftKey', { value: true, writable: false });
        drop(ev);
    }
    
    function dragenter(ev) {
        ev.preventDefault();
        
        if (!isDragActive) {
            isDragActive = true;
            isDragInProgress = true; // Mark that a drag is happening globally
            hasShownHintForCurrentDrag = false; // Reset hint tracking for new drag
            const terminal = document.getElementById('terminal');
            terminal.classList.add('drag-over');
            
            // SUCCESS! User got drag working again - hide any hint
            hideDragHint();
        }
    }
    
    function dragover(ev) {
        ev.preventDefault();
        
        // Ensure we stay active during drag
        if (!isDragActive) {
            isDragActive = true;
            const terminal = document.getElementById('terminal');
            terminal.classList.add('drag-over');
        }
    }
    
    function dragleave(ev) {
        ev.preventDefault();
        
        // Reset drag state immediately when leaving
        if (isDragActive) {
            isDragActive = false;
            const terminal = document.getElementById('terminal');
            terminal.classList.remove('drag-over');
            
            // Show hint for wandering drags
            if (isDragInProgress && !hasShownHintForCurrentDrag) {
                setTimeout(() => {
                    if (isDragInProgress && !isDragActive && !hasShownHintForCurrentDrag) {
                        showDragHint();
                    }
                }, 400);
            }
        }
    }
    
    function showDragHint() {
        const hint = document.getElementById('drag-hint');
        if (!hint) return;
        
        // Mark that we've shown the hint for this drag session
        hasShownHintForCurrentDrag = true;
        
        // Clear any existing timeout
        if (hintTimeout) {
            clearTimeout(hintTimeout);
        }
        
        // Fade in the hint
        hint.classList.add('show');
        
        // Fade out after 30 seconds
        hintTimeout = setTimeout(() => {
            hideDragHint();
        }, 30000);
    }
    
    function hideDragHint() {
        const hint = document.getElementById('drag-hint');
        if (!hint) return;
        
        hint.classList.remove('show');
        if (hintTimeout) {
            clearTimeout(hintTimeout);
            hintTimeout = null;
        }
    }
    

    function drop(ev) {
        ev.preventDefault();
        
        // Clean up drag UI state
        isDragActive = false;
        const terminal = document.getElementById('terminal');
        terminal.classList.remove('drag-over');
        
        // SUCCESS! Hide any hint since drag & drop worked
        hideDragHint();
        
        
        if (ev.dataTransfer.files.length > 0) {
            for (let i = 0; i < ev.dataTransfer.files.length; i++) {
                const file = ev.dataTransfer.files[i];
                
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    handleDroppedFile(file, e.target.result);
                };
                
                reader.onerror = (e) => {
                    handleDroppedFile(file, null);
                };
                
                // Read based on file type
                if (file.type.startsWith('image/')) {
                    // For images, read as data URL (base64)
                    reader.readAsDataURL(file);
                } else if (file.type.startsWith('text/') || file.name.endsWith('.txt') || file.name.endsWith('.md') || file.name.endsWith('.json') || file.name.endsWith('.csv')) {
                    // For text files, read as text
                    reader.readAsText(file);
                } else {
                    // For other files, read as data URL
                    reader.readAsDataURL(file);
                }
            }
        }
        
        ev.target.value = `Dropped ${ev.dataTransfer.files.length} file(s) - reading...`;
    }
    
    function handleDroppedFile(file, fileData) {
        
        // Send message to extension host with the raw file data
        if (typeof vscode !== 'undefined') {
            vscode.postMessage({ 
                command: 'fileDrop', 
                fileName: file.name,
                fileType: file.type,
                fileSize: file.size,
                fileData: fileData
            });
        }
    }
</script>


    <div id="terminal">
        <div id="drag-hint">💡 Press Shift To Resume Drag & Drop</div>
    </div>
    
    <script src="{{XTERM_URI}}"></script>
    <script src="{{FIT_ADDON_URI}}"></script>
    <script src="{{WEBGL_ADDON_URI}}"></script>
    <script src="{{CANVAS_ADDON_URI}}"></script>
    <script>
        {{TERMINAL_SCRIPT}}
        
        // Initialize drag-drop capture
        if (typeof setupDragCapture === 'function') {
            setupDragCapture();
        }
    </script>
</body>
</html>